一、Compose是什么
  Compose是构建原生android界面的新工具包，使用更少的代码，强大的工具和直观的kotlin API，更快速，更轻松地构建界面，简化并加速了界面的开发，打造生动而精彩的应用（目的）。
  Compose采用的是命令式界面模型，提供声明性API，不以命令方式改变视图的情况下呈现应用界面，从而使编写和维护应用界面变得更加容易。

  命令式界面模型：
     Android之前一直表示为界面Widget树结构，应用的状态会因用户交互等因素而发生改变，界面层级结构需要进行更新以显示当前数据
     创建：通过实例化 widget 树来初始化界面或者通过膨胀 XML 布局文件。每个 widget 都维护自己的内部状态，并且提供 getter 和 setter 方法，允许应用逻辑与 widget 进行交互。
     更新方式：使用findViewById等函数遍历界面树，并通过setXXX，addXXX等方法更改节点，这些方法会改变widget的内部状态
     缺点：手动操作视图会提高出错的可能性，例如一条数据在多个位置呈现，容易忘记更新显示它某个视图
          当两项更新出乎意料的方式发生冲突时，容易造成异常状态，例如某项更新尝试设置已经从界面树移除的节点的值
          软件维护的复杂性会随着需要更新的视图数量而增长
  声明式界面模型：
     是在概念上从头开始重新生成整个屏幕，在时间，计算能力和电池用量方便可能成本高昂，为了减少在这方面资源的耗费，Compose会智能地重组已更改的组件。即仅执行必要的更改。
     更新方式：在 Compose 中，界面是不可变的，在绘制后无法进行更新。可以控制的是界面的状态。每当界面的状态发生变化时，Compose 都会重新执行界面树中已更改的部分。
     优点：
        大大简化了构建和更新界面关联的工程任务
        避免手动更新有状态视图层级结构的复杂性

优点
   更少的代码
      与AndroidView系统（列表，按钮，动画）对比，Compose使用更少的代码实现更多的功能。 无论要构建什么，使用Compose编写的代码更简洁，更容易维护。
    =================================================================================================
    原因：Compose的布局系统在概念上更简单，采用声明式模型，通过对界面的描述和状态控制，更轻松推断，更轻松查看复杂组件代码
    影响：作为代码撰写者，需要测试和调试的代码会更少，出现 bug 的可能性也更小，可以专注于解决手头的问题。
         作为审核人员或维护人员，需要阅读、理解、审核和维护的代码就更少。

   直观
      Compose 使用声明性 API，这意味着只需描述界面，Compose 会负责完成其余工作，这类API十分直观，易于探索和使用
      封装分离：在Compose中，将在界面中显示状态的可组合项与应用中存储和更改状态的部分进行分离，确保状态具有单一可信来源，当状态变化时，界面立即自动更新，保证了界面的一致性。
      对比AndroidView系统不必处理太多信息，并且出现bug几率很小。
      重用/维护/测试:在Compose中可以构建不与特定 activity 或 fragment 相关联的小型无状态组件，可以轻松重用和测试这些组件。
                   同时提供有状态和无状态的界面组件，对应不同的场景，使组件更加易于使用和维护，且可直观实现/扩展/自定义

   加速开发
      编写代码只需要采用 Kotlin，而不必拆分成 Kotlin 和 XML 部分，所有代码都使用同一种语言编写并且通常位于同一文件中（而不是在 Kotlin 和 XML 语言之间来回切换）时，让开发调试效率更高。
      借助Android Studio实时预览等功能，构建多个预览的能力，检查不同状态下或采用不同设置的界面组件（例如错误状态或采用不同的字体大小等），帮我们节省了时间。

   功能强大
      API：在Compose中可以对 Android 平台API的直接访问和对于 Material Design、深色主题、动画等的内置支持，Compose 不仅解决了声明性界面的问题，还改进了无障碍功能 API、布局等各种内容。将设想变为现实所需的步骤更少了。
      动画：在Compose中可以轻松快速地通过动画让应用变得生动有趣，而且添加动画效果非常简单，为颜色/大小/高度变化添加动画效果，不需要任何特殊的工具就能制作动画，这与显示静态屏幕没有什么不同。
      设计系统：无论是使用MaterialDesign还是自己的设计系统进行构建，Compose都可以灵活地实现所需的设计，因为基础层（Foundation）与Material层是分离的，如果使用MaterialDesign系统可以直接调用Material层，如果要构建自己的设计系统，可以基于Foundation层构建。
      兼容性：Compose 可以与所有的现有代码兼容：可以从 View 调用 Compose 代码，也可以从 Compose 调用 View， 大多数常用库（如 Navigation、ViewModel 和 Kotlin 协程）都适用于 Compose。
      kotlin编写：可以使用循环，调用辅助函数，拥有底层语言的全部灵活性。

二、Compose架构
    设计：
    1.项目和组件都不是单体式
    Compose项目不是单体式的，由多个模块构建而成，这些模块组合在一起，构建成一个完成的架构
    组件也不是单体式的，提供可以组合在一起的重点突出的小功能片段，注意这些组件是可以重复使用的，是分层的。

    2.分层
    Runtime：
        提供了Compose运行时的基本组件。例如：remember，State，SideEffect，注解
        如需要Compose的界面树管理功能，而不需要界面，可以基于此层构建

    UI：界面层，由ui-text，ui-graphics，ui-tooling，ui-geometry多个模块组成。这些模块实现了界面工具包的基本组件。例如：Text，绘图，自定义布局，输入处理，Modifier，LayoutNode
       如需用到Compose的界面工具包的基本概念，可以基于此层进行构建

    Foundation：为Compose界面提供了与设计系统无关的构建块。例如：Row,Colum,LazyRow,LazyColum,手势识别
              如需自定义设计系统，可以基于此层进行构建

    Material：为Compose界面提供了MaterialDesign系统的实现。同时提供一个主题系统、若干样式化组件、涟漪效果指示元素和图标
              如需使用MaterialDesign可以基于此层进行构建


   使用：
    1.选择合适的抽象层级，尽可能的减少依赖项。
       越高级别的组件往往能完成操作越多，但是拥有的直接控制权较少，如果需要更多控制权，可以通过“降级”使用较低级别组件，
       较低级别的 API 的过程更为复杂，但可以获取更多的控制权或更高的自定义程度。
       根据应用场景选择最符合需求的抽象层级进行构建。

     建议：最好基于能提供所需功能的最高级别的组件进行构建，以便从其包含的最佳实践中受益，但高级别不合适时，“降级”到较低级别

     示例：
       1.为某个组件的颜色添加动画效果
       2.为自定义组件添加手势支持，

    2.自定义组件
       a、通过将较小的构建块组合成更高级别的组件，可大幅降低按需自定义组件的难度
       b、如果希望在组件的参数之外进行自定义，可以“降级”到某个级别并为组件创建分支，应以对应的组件作为指导。
     建议：为组件创建分支意味着，不会从上游组件的任何未来增补项或 bug 修复中受益，不要忽视无障碍功能支持等原因而使任何功能发生降级。
     示例：
      1.Material层中Button的实现
      2.Material中指定按钮应具有纯色背景


三、单向数据流在Compose的应用（实践指导）
   单向数据流 (UDF) 是一种设计模式，在该模式下状态向下流动，事件向上流动（参考图例）

   Compose中采用单项数据流
   Compose中可组项可以接受状态并公开事件，非常适合采用单向数据流模式（基于可组项的状态和事件），采用单向数据流后，可以将在界面中显示状态的可组合项与应用中存储和更改状态的部分进行分离。

     状态：Compose将State对象定义为值容器，而对状态值的更改会触发重组。一般状态保存在 remember { mutableStateOf(value) } 或 rememberSaveable { mutableStateOf(value) 中，具体情况取决于需要记住值的时长。
     事件：应用的每项输入都应表示为事件(例如：点按、文本更改，甚至计时器或其他更新),
         事件是更改界面的状态，必须是一个位置更新状态防止出现不一致的情况；一般是可组项，状态容器，ViewModel负责处理这些事件并更新界面状态，

     状态和事件传递不可变值：函数参数层层传递，在唯一可信来源进行修改。
        状态:为原始数据类型或状态类型。
        事件:定义函数类型，向上传递，最终在唯一可信来源进行状态更改。
           调用：a、 直接赋值，函数引用 b、在lambda作用域内调用
        优势：
          a.提升可重用性。
          b.确保界面不会直接更改状态的值
          c.避免并发问题，确保不会从其他线程修改状态。
          d.降低了代码的复杂性。

     示例：定义更通用的 MyAppTopAppBar


   Compose中单向数据流的运行过程（界面更新循环）：
      事件：界面的某一部分生成一个事件，并将其向上传递。例如：按钮点击事件传递给ViewModel进行处理，或者其他层传递事件，数据更新
      更新状态：事件处理脚本更改状态。
      显示状态:状态容器向下传递状态，界面显示次状态。

   采用单向数据流的优势：
      可测试性：将状态与显示状态的界面进行分离，更方便单独对二者进行测试。
      状态封装：状态只能在一个位置进行更新，并且可组合项的状态只有一个可信来源，所以不太可能由于状态不一致而出现 bug。
      界面一致性：通过使用可观察的状态类型（例如：StateFlow 或 LiveData），所有状态更新都会立即反映在界面中。

   ViewModel，状态、事件的关系
      1、ViewModel中通过mutableStateOf， StateFlow 或 LiveData 等可观察的状态容器公开。提供给界面显示，
      2、ViewModel处理来自应用界面或其他层的事件，并根据事件更新状态容器。

   示例：TextField的更新
        实现登录屏幕

四、Compose编程思想




五、Compose核心元素
   可组合项
     是一组接收数据而发出界面元素的可组合函数，用于来构建界面
     特点：带有@Composable注释。所有可组合函数都必须带有此注释，此注释告知Compose编译器此函数旨在将数据转换为界面
          接收数据。
             可组合函数可以接受一些参数，这些参数可让应用逻辑描述界面。在本例中，我们的 widget 接受一个 String，因此它可以按名称问候用户。
          在界面中显示内容。
              显示文本，图片等等，例如：它会调用 Text() 可组合函数，该函数实际上会创建文本界面元素
              可组合函数通过调用其他可组合函数来发出界面层次结构。
          不会返回任何内容。
             发出界面的 Compose 函数不需要返回任何内容，因为它们描述所需的屏幕状态，而不是构造界面 widget。
          快速，幂等且没有附带效应。
             a、此函数描述界面而没有任何副作用，如修改属性或全局变量
             b、使用同一参数多次调用此函数时，它的行为方式相同，并且它不使用其他值，如全局变量或对 random() 的调用

     优点：于可组合函数是用 Kotlin 而不是 XML 编写的，因此它们可以像其他任何 Kotlin 代码一样动态。

     参数
           参数定义思考
              可组合项的可重用性或灵活性如何
              状态参数如何影响此可组合项的性能

           参数定义规则
               参数尽可能包含少的信息
                   为了促进分离和重复使用，每个可组合项都应包含尽可能少的信
                   例如：构建可组合项以保存新闻报道的标题时，最好仅传递需要显示的信息，而不是整篇新闻报道

               独立参数提高性能
                    例如：如果 News 包含的不仅仅是 title 和 subtitle 的信息，每当有 News 的新实例传入 Header(news) 时，即使 title 和 subtitle 没有变化，可组合项也将重组。

               参数过多处理
                    如果一个函数拥有过多参数，会降低该函数的工效，因此在这种情况下，建议您将这些参数分到一个类下。


     隐式传参（CompositionLocal）
         背景：通常情况下，在 Compose 中，数据以参数形式向下流经整个界面树传递给每个可组合函数，这是显示传参。
             对一些广泛使用的常用数据（如颜色，样式），这种层层传递的方式非常的繁琐麻烦。Compose为了解决这类问题，引入了隐式传参。

         CompositionLocal是通过组合隐式向下传递数据的工具。创建以树为作用域的工具对象，是让数据流经界面树的一种隐式方式。该参数为横切参数且中间层的实现不应知道该参数的存在。
         特点：1.CompositionLocal 元素通常在界面树的某个节点以值的形式提供。该值可供其可组合项的后代使用，而无需在可组合函数中将 CompositionLocal 声明为参数
              2.CompositionLocal 实例的作用域限定为组合的一部分，因此可以在结构树的不同级别提供不同的值

         使用：
              使用场景
                 使用 CompositionLocal 的情况为：其可能会被任何（而非少数几个）后代使用。

              不适合的场景，使用显示传参
                  1.并非以树或子层次结构为作用域，避免使用 CompositionLocal
                  2.参数只被几个子级使用，而非全部子级使用

              创建
                 compositionLocalOf
                    在重组期间更改提供的值只会使读取其current值的内容无效，智能重组，没变化的跳过

                 staticCompositionLocalOf：定义提供的值不会发生更改的类型，如果值发生变化核心重组整个content lambda，没有变化的也会重组，会影响性能
                    与 compositionLocalOf 不同，Compose 不会跟踪 staticCompositionLocalOf 的读取。更改该值会导致提供 CompositionLocal 的整个 content lambda 被重组，而不仅仅是在组合中读取 current 值的位置。
                    如果为 CompositionLocal 提供的值发生更改的可能性微乎其微或永远不会更改，使用 staticCompositionLocalOf 可提高性能。

              常用API
                 实例对象.current  //获取当前隐式参数
                    1、对应于该组合部分中的某个祖先提供的最接近的值。
                    2、返回由最接近的 CompositionLocalProvider（其向该 CompositionLocal 提供一个值）的 content lambda 将获取提供的值

                 CompositionLocalProvider(实例对象 provides 新值){   }  //修改隐式参数的值，应为范围在其构建块内
                    CompositionLocalProvider 可组合项可将值绑定到给定层次结构的 CompositionLocal 实例
                    如需为 CompositionLocal 提供新值，使用 CompositionLocalProvider 及其 provides infix 函数，该函数将 CompositionLocal 键与 value 相关联。提供新值后，Compose会重组读取 CompositionLocal 的组合部分。

         Compose中常用的CompositionLocal实例
              1.MaterialTheme中的colors、typography、shapes
              2.LocalContext，LocalConfiguration，LocalLifecycleOwner，LocalView，LocalSavedStateRegistryOwner，LocalImageVectorCache

         缺点
              1.CompositionLocal使得可组合项的行为更难推断。在创建隐式依赖项后，使用这些依赖项的可组合项的调用方可能会给CompositionLocal提供一个新的值。
              2.依赖项可能没有明确的可信来源。它可能会在组合中的任何部分发生改变。导致出现问题时调试麻烦，缓解：Android Studio 中的“Find usages”或 Compose 布局检查器


         开发建议：
              1.CompositionLocal应具有一个的默认值，如果没有默认值，始终需要显示提供值，如果不提供导致报错
              2.不要使用CompositionLocal封装ViewModel。
                  创建包含特定屏幕的 ViewModel 的 CompositionLocal，以便该屏幕中的所有可组合项都可以获取对 ViewModel 的引用来执行某些逻辑，这是一种错误做法，因为并非特定界面树下的所有可组合项都需要知道ViewModel
                  最佳做法是遵循状态向下传递而事件向上传递的模式，只向可组合项传递所需信息。这样做会使可组合项的可重用性更高，并且更易于测试。

     显示传参
         显式使用可组合项的依赖项。建议仅传递所需可组合项，不要传整个数据对象和一些不必要的信息，为了鼓励分离和重用可组合项，每个可组合项包含的信息应该可能少。

         显示传参的控制反转，
             避免将不必要的依赖项传递给可组合项。不是由后代接受依赖项来执行某些逻辑，而是由父级接受依赖项来执行某些逻辑。

               优缺点：低级别的可组合项更灵活，祖先实体可组合项可能会越来越复杂，使用状态容器或者ViewModel进行解耦，封装分离

               使用：
                   1、事件提升
                       不将依赖项传递到子级，通过事件提升，让父级负责执行逻辑；针对逻辑的封装。

                   2、可组合项提升
                       使用 @Composable注解函数类型，抽象层级更高，针对可组合项的封装

               示例









=========================================================================================================================================

   状态

=========================================================================================================================================

   重组
     使用新数据再次调用可组合函数，系统会根据需要使用新数据重新绘制函数发出的界面元素。
     考虑到性能方面：Compose 框架可以智能地仅重组已更改的组件




===============
不同的维度
  思想：声明式模型，单向数据流，智能重组，可组合函数
  核心元素 可组合项，状态，重组
  常用API