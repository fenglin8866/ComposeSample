应用界面：根布局是View，然后嵌套一个可组合项，由一个个组合组成，组合之间相互嵌套
         组合：描述应用界面，通过运行可组合项来生成，是可组合项的树结构。
              组合与可组合项的关系：组合是通过运行可组合项生成的树结构。是一个抽象的概念，方便描述应用界面。
      组合更新：组合只能通过初始组合生成且只能通过重组进行更新。重组是修改组合的唯一方式。
         重组：1.当Compose首次运行可组合项时，在初始组合期间，它将跟踪为了描述组合中的界面而调用的可组合项，当应用的状态发生变化时，
              Compose重新执行可能因状态更改而更改的可组合项，然后更新组合以反映所有更改。
              2. 重组通常由对 State<T> 对象的更改触发。Compose 会跟踪这些操作，并运行组合中读取该特定 State<T> 的所有可组合项以及这些操作调用的无法跳过的所有可组合项。

界面的生命周期：
      进入组合，执行0次或多次重组，退出组合。
           说明：可组合项的生命周期比视图、activity 和 fragment 的生命周期更简单。当可组合项需要管理生命周期确实更复杂的外部资源或与之互动时，应使用效应。
                如果某一可组合项多次被调用，在组合中将放置多个实例。每次调用在组合中都有自己的生命周期。

组合的生成过程
       组合中可组合项的实例由其调用点（是调用可组合项的源代码位置。这会影响其在组合中的位置，因此会影响界面树）进行标识，Compose 编译器将每个调用点都视为不同的调用点，
       从多个调用站点调用可组合项会在组合中创建多个可组合项实例，每个调用都有唯一的调用点和源位置，编译器将使用它们对调用进行唯一识别；
       在重组期间，可组合项调用的可组合项与上个组合期间调用的可组合项不同，Compose将确定调用或未调用的可组合项，对于在两次组合中均调用的可组合项，如果输入未更改，Compose将避免重组这些可组合项。
       保留身份（remember）对于将附带效应与可组合项相关联十分重要，这样它们才能成功完成，而不是每次重组时都重新启动


   重组：添加额外信息以促进智能重组
            多次调用同一可组合项也会多次将其添加到组合中
            如果从同一个调用点多次调用某个可组合项
              问题：Compose 就无法唯一标识对该可组合项的每次调用
              解决：除了调用点之外，还会使用执行顺序来区分实例
                  新问题：  如果因在调用点列表顶部或中间新增内容，移除项目或对项目进行重新排序而导致列表数据发生改变
                           将导致输入参数在列表中的位置已更改的所有子项调用发生重组
                           如果子项中使用了附带效应，并在使用附带效应的过程中发生重组，系统就会取消重组并重新开始。
                  解决思路： 理想情况下，认为 子项 实例与传递到该实例的 数据 相关联。如果列表进行重新排序，以比较方式在组合树中对实例进行重新排序，而不是将每个子可组合项与不同数据实例进行重组。
                  解决：
                        使用一些值来标识树的给定部分：key 可组合项。
                             通过调用带有一个或多个传入值的键可组合项来封装代码块，这些值将被组合以用于在组合中标识该实例
                             key 的值不必是全局唯一的，只需要在调用点处调用可组合项的作用域内确保其唯一性即可。
                             核心：使用key可组合项帮助Compose识别组合中的可组合项实例。当从同一个调用点调用多个可组合项，且这些可组合项包含附带效应或内部状态时，这一点非常重要。

                  一些可组合项提供对 key 可组合项的内置支持。
                      例如：LazyColumn 接受在 items DSL 中指定自定义 key
                          @Composable
                          fun MoviesScreen(movies: List<Movie>) {
                              LazyColumn {
                                  items(movies, key = { movie -> movie.id }) { movie ->
                                      MovieOverview(movie)
                                  }
                              }
                          }
            ==================================================

            @Composable
            fun MoviesScreen(movies: List<Movie>) {
                Column {
                    for (movie in movies) {
                        key(movie.id) { // Unique ID for this movie
                            MovieOverview(movie)
                        }
                    }
                }
            }

            @Composable
            fun MovieOverview(movie: Movie) {
                Column {
                    // Side effect explained later in the docs. If MovieOverview
                    // recomposes, while fetching the image is in progress,
                    // it is cancelled and restarted.
                    val image = loadNetworkImage(movie.url)
                    MovieHeader(image)

                    /* ... */
                }
            }

        如果输入未更改，则跳过
            概念： 如果组合中已有可组合项，当作为参数传递到可组合项的所有类型都处于稳定状态时，系统会根据可组合项在界面树中的位置来比较参数值，以确保相等性。如果所有值自上次调用后未发生变化，则会跳过重组。
            要点：如果可组合项中所有输入都稳定并且没有更改，Compose 将跳过重组可组合项。比较使用了 equals 方法。

        稳定类型
            协定：对于相同的两个实例，其 equals 的结果将始终相同。
                 如果类型的某个公共属性发生变化，组合将收到通知。
                 所有公共属性类型也都是稳定
            默认归入稳定类型的通用类型
                即使未使用 @Stable 注解来显式标记为稳定的类型，Compose 编译器也会将其视为稳定的类型。
                所有这些类型都可以遵循稳定协定，因为它们是不可变的。由于不可变类型绝不会发生变化，它们就永远不必通知组合更改方面的信息，因此遵循该协定

                所有基元值类型：Boolean、Int、Long、Float、Char 等。
                字符串
                所有函数类型 (lambda)
            注意：
               所有深层不可变的类型都可以被安全地视为稳定类型

            MutableState 类型
               是一种众所周知稳定但可变的类型
               如果 MutableState 中存储了值，状态对象整体会被视为稳定对象，因为 State 的 .value 属性如有任何更改，Compose 就会收到通知。


        不稳定类型
            概念
              接口通常被视为不稳定类型
              具有可变公共属性的类型（实现可能不可变）的类型也被视为不稳定类型。

            强制Compose视为稳定类型
              如果 Compose 无法推断类型是否稳定，但想强制 Compose 将其视为稳定类型，请使用 @Stable 注解对其进行标记
              目的：让 Compose 优先选择智能重组

            要点：如果 Compose 无法推断某个类型的稳定性，请为该类型添加 @Stable 注解，让 Compose 优先选择智能重组。

            示例：
            // Marking the type as stable to favor skipping and smart recompositions.
            @Stable
            interface UiState<T : Result<T>> {
                val value: T?
                val exception: Throwable?

                val hasError: Boolean
                    get() = exception != null
            }